# 文件目录转化成对象

```
├── a
│   └── b
│       ├── c1.js
│       └── c2.js
└── d
    ├── e1.js
    └── e2.js
```

require.context 是 Webpack 提供的一个动态导入功能，它允许你从指定的目录中加载模块。这在需要批量导入多个文件时非常有用，例如自动加载目录下的所有模块，而不需要逐个手动导入。

**用法**
require.context 的基本用法如下：
```js
const context = require.context(directory, useSubdirectories, regExp);
```
- directory ：你想要检索模块的目录。
- useSubdirectories ：是否检索子目录 (true 或 false)。
- regExp ：匹配文件的正则表达式。

```js
// --run--
const path = require("path");

const loadModulesFromContext = (directories) => {
  const result = {};
  const useSubdirectories = true;
  const regExp = /\.js$/;
  directories = Array.isArray(directories) ? directories : [directories];
  directories.forEach(directory => {
    const absolutePath = path.resolve(process.cwd(), directory);
    const relativePath = path.normalize(path.relative(__dirname, absolutePath));
    // NOTE - require.context 仅在构建时工作，它依赖 Webpack 的静态分析，因此不能使用动态路径。路径应该是字面常量，而不是变量或函数结果
    // 第二个和第三个参数可以根据你的需求设置为布尔值或正则表达式，它们也可以是变量，但需要注意的是这些变量的值必须在编译时是静态确定的。
    const ctx = require.context('./a', true, /\.js$/);
    // ctx.keys() 返回当前目录下所有文件的相对路径，比如 /a 目录下的 ./b/c1.js
    ctx.keys().forEach(key => {
      // 解析路径，比如 ./a/b/c1.js
      const resolvedPath = ctx.resolve(key);
      // 获取模块的默认导出，比如 function () { return 'c1';}
      const module = ctx(key);
      // 通过正则匹配路径，获取路径中的目录名，比如 ['a', 'b', 'c1']
      const matches = resolvedPath.match(/[^\.\/]+/g).slice(0, -1);
      const original = {};
      let current = original;
      matches.forEach((match, index) => {
        if (index === matches.length - 1) {
          current[match] = module;
        } else {
          current = current[match] = current[match] || {};
        }
      });
      Object.assign(result, original);
    });
  });

  return result;
}


const modules = loadModulesFromContext(['./a', './d']);
console.log(modules);


```
